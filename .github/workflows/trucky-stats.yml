name: Update Trucky Stats

on:
  workflow_dispatch:
  schedule:
    - cron: "*/30 * * * *"

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Discover Trucky endpoints and write trucky.json
        env:
          TRUCKY_ACCESS_TOKEN: ${{ secrets.TRUCKY_ACCESS_TOKEN }}
        run: |
          python3 - << 'PY'
          import json, datetime, urllib.request, os, re

          COMPANY_ID = 43152
          token = os.environ.get("TRUCKY_ACCESS_TOKEN","").strip()
          if not token:
            raise SystemExit("Missing TRUCKY_ACCESS_TOKEN secret")

          HEADERS = {
            "Accept": "application/json",
            "User-Agent": "BlackRavenLogisticsSite/1.0 (GitHub Actions)",
            "x-access-token": token,
          }

          # ---- 1) Try to fetch Trucky OpenAPI spec (public) ----
          # These are common locations; we'll try a few.
          openapi_urls = [
            "https://e.truckyapp.com/api/openapi.json",
            "https://e.truckyapp.com/openapi.json",
            "https://e.truckyapp.com/swagger/v1/swagger.json",
            "https://e.truckyapp.com/swagger.json",
          ]

          spec = None
          spec_url = None
          for u in openapi_urls:
            try:
              with urllib.request.urlopen(urllib.request.Request(u, headers={"User-Agent": "BRL-Site-Discovery/1.0"}), timeout=20) as r:
                raw = r.read().decode("utf-8", errors="replace")
              j = json.loads(raw)
              if isinstance(j, dict) and "paths" in j:
                spec = j
                spec_url = u
                break
            except Exception:
              pass

          if not spec:
            # If OpenAPI isn't publicly reachable, we still do a minimal fallback
            print("OpenAPI spec not found at known URLs. Falling back to minimal endpoints.")
            paths = []
          else:
            paths = list(spec.get("paths", {}).keys())
            print("OpenAPI loaded from:", spec_url)
            print("Paths in spec:", len(paths))

          # ---- 2) Build candidate API URLs for company stats ----
          # We look for any path that:
          # - contains "company" or "vtc"
          # - contains "{id}" or "{companyId}" etc.
          # - and has keywords like stats/month/alltime/leaderboard/deliveries/jobs/distance
          keywords = ("stat", "month", "alltime", "week", "year", "deliver", "job", "distance", "mileage", "leaderboard")
          id_patterns = ("{id}", "{companyId}", "{company_id}", "{vtcId}", "{vtc_id}")
          base = "https://e.truckyapp.com"

          candidates = []
          for p in paths:
            pl = p.lower()
            if ("company" in pl or "vtc" in pl) and any(ip in p for ip in id_patterns) and any(k in pl for k in keywords):
              candidates.append(p)

          # Also include a few sane guesses that sometimes exist
          guesses = [
            "/api/v1/company/{id}/stats",
            "/api/v1/company/{id}/statistics",
            "/api/v1/company/{id}/overview",
            "/api/v1/company/{id}/summary",
            "/api/v1/company/{id}/reports/monthly",
            "/api/v1/company/{id}/reports/alltime",
            "/api/v1/company/{id}/timeline/month",
            "/api/v1/company/{id}/deliveries/month",
            "/api/v1/company/{id}/deliveries",
            "/api/v1/company/{id}/jobs",
          ]
          candidates = list(dict.fromkeys(candidates + guesses))

          # Substitute ID placeholder
          def fill(path):
            out = path
            for ip in id_patterns:
              out = out.replace(ip, str(COMPANY_ID))
            return out

          # ---- 3) Fetch company basic info (members) ----
          company_url = f"{base}/api/v1/company/{COMPANY_ID}"
          def get_json(url, headers):
            req = urllib.request.Request(url, headers=headers)
            with urllib.request.urlopen(req, timeout=25) as resp:
              raw = resp.read().decode("utf-8", errors="replace")
            return json.loads(raw)

          company = get_json(company_url, HEADERS)
          members = company.get("members_count", None)

          # ---- 4) Try candidates until we find jobs/distance for ATS ----
          found = []
          errors = {}

          def deep_find(obj, keys):
            if isinstance(obj, dict):
              for k, v in obj.items():
                if k in keys:
                  return v
                f = deep_find(v, keys)
                if f is not None:
                  return f
            elif isinstance(obj, list):
              for it in obj:
                f = deep_find(it, keys)
                if f is not None:
                  return f
            return None

          def extract_jobs_distance(payload):
            # Try to find ATS-specific areas first
            # Common keys: ats, game="ats", game_id etc.
            # We'll attempt a few heuristics.

            # 1) Direct "ats" dict
            if isinstance(payload, dict) and "ats" in payload and isinstance(payload["ats"], dict):
              block = payload["ats"]
              jobs = deep_find(block, {"jobs", "jobsCount", "total_jobs", "job_count"})
              dist = deep_find(block, {"distance", "miles", "kilometers", "total_distance", "mileage"})
              return jobs, dist

            # 2) Games dictionary
            games = payload.get("games") if isinstance(payload, dict) else None
            if isinstance(games, dict) and "ats" in games and isinstance(games["ats"], dict):
              block = games["ats"]
              jobs = deep_find(block, {"jobs", "jobsCount", "total_jobs", "job_count"})
              dist = deep_find(block, {"distance", "miles", "kilometers", "total_distance", "mileage"})
              return jobs, dist

            # 3) List items with game field
            if isinstance(payload, dict):
              for k in ("stats","statistics","data","items","results"):
                v = payload.get(k)
                if isinstance(v, list):
                  for it in v:
                    if isinstance(it, dict) and str(it.get("game","")).lower() == "ats":
                      jobs = deep_find(it, {"jobs", "jobsCount", "total_jobs", "job_count"})
                      dist = deep_find(it, {"distance", "miles", "kilometers", "total_distance", "mileage"})
                      return jobs, dist

            # 4) Last resort: any jobs/distance in payload
            jobs = deep_find(payload, {"jobs", "jobsCount", "total_jobs", "job_count"})
            dist = deep_find(payload, {"distance", "miles", "kilometers", "total_distance", "mileage"})
            return jobs, dist

          jobs = None
          dist = None
          used_endpoint = None

          for p in candidates:
            url = base + fill(p)
            try:
              payload = get_json(url, HEADERS)
              j, d = extract_jobs_distance(payload)
              # Accept if we got at least one meaningful value
              if j is not None or d is not None:
                jobs, dist = j, d
                used_endpoint = url
                found.append(p)
                break
            except Exception as e:
              errors[url] = str(e)

          # Format distance: your Trucky UI shows miles, so we label as mi by default.
          distance_text = None
          if dist is not None:
            try:
              distance_text = f"{int(float(dist)):,} mi"
            except:
              distance_text = str(dist)

          out = {
            "members": members,
            "jobs": jobs,
            "distance_text": distance_text,
            "rating": None,
            "updated_utc": datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M"),
            "source_company": company_url,
            "source_stats": used_endpoint,
            "openapi_spec": spec_url,
            "tried_paths": len(candidates),
          }

          with open("trucky.json", "w", encoding="utf-8") as f:
            json.dump(out, f, ensure_ascii=False, indent=2)

          print("WROTE trucky.json:", out)
          if errors:
            print("Some errors (first 10):")
            for i,(k,v) in enumerate(errors.items()):
              if i>=10: break
              print(k, "->", v)
          PY

      - name: Commit & push if changed
        run: |
          if git diff --quiet; then
            echo "No changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add trucky.json
          git commit -m "chore: update Trucky stats"
          git push
